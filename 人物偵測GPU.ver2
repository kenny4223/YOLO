# =========================================================
# 步驟 1: 安裝、導入與檔案路徑設定
# =========================================================
print("--- 步驟 1/3: 設置環境與路徑設定 ---")

# 確保您已經在終端機中執行過: pip install ultralytics opencv-python

# 導入所有必要的模組
import cv2
import torch
import time
from ultralytics import YOLO
import os 
import sys 

# --- 本機檔案路徑設定 (必修改!) ---
# ⚠️ 這裡必須修改為您電腦上影片的【絕對路徑】或【相對路徑】
# 範例 (Windows): "D:\\MyVideos\\input_video.mp4"
# 範例 (macOS/Linux): "/Users/YourName/Videos/input_video.mp4"
video_path = "D:\\MyVideos\\input_video.mp4"  # <-- 請將此處替換為您的影片路徑
output_path = "output_tracked_video.mp4" 

# 檢查輸入檔案是否存在
if not os.path.exists(video_path):
    print(f"❌ 錯誤: 在指定路徑找不到影片檔案: {video_path}")
    print("請修改程式碼中的 video_path 變數為正確的本機路徑。")
    sys.exit()

print(f"✅ 讀取影片路徑: {video_path}")
print(f"✅ 輸出影片將儲存至: {os.path.abspath(output_path)}")


# --- 模型與硬體設定 ---
# 載入 YOLOv8 nano 模型
model = YOLO('yolov8n.pt') 

# 設置裝置 (本機運行時，如果沒有 CUDA，會自動使用 CPU)
device = "cuda" if torch.cuda.is_available() else "cpu"
model.to(device)
print(f"✅ 使用的裝置: {device}")

# 模型輸入尺寸
INFERENCE_IMG_SIZE = 320
print(f"📏 模型輸入尺寸: {INFERENCE_IMG_SIZE}x{INFERENCE_IMG_SIZE}")


# =========================================================
# 步驟 2: YOLOv8 影片處理迴圈 (只保留 Process FPS)
# =========================================================
print("\n--- 步驟 2/3: 影片處理與追蹤 (將彈出即時視窗) ---")

# 讀取影片檔
cap = cv2.VideoCapture(video_path)

if not cap.isOpened():
    print("❌ 影片讀取失敗，請檢查檔案格式或路徑是否正確。")
    sys.exit()

# 獲取影片屬性
original_fps = cap.get(cv2.CAP_PROP_FPS)
frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
print(f"🎬 影片原始尺寸: {frame_width}x{frame_height}, 原始 FPS: {original_fps:.2f}")

# 影片輸出設置
fourcc = cv2.VideoWriter_fourcc(*'mp4v') 
# 為了避免編碼器問題，輸出 FPS 暫時設為 30，您可以根據需要調整
out = cv2.VideoWriter(output_path, fourcc, original_fps, (frame_width, frame_height)) 

if not out.isOpened():
    print("❌ 警告：影片寫入器開啟失敗，請檢查是否安裝了正確的編碼器 (例如 FFmpeg)。")
    
# 初始化用於計算 FPS 的變數
prev_time = time.time() 
frame_count = 0 
total_start_time = time.time() 
processing_fps = 0.0

print("⏳ 開始高速處理影片... (按 'q' 鍵退出，按 ' ' 鍵暫停)")

paused = False # 新增暫停狀態變數
window_name = "YOLOv8 Object Tracking (Local)"
cv2.namedWindow(window_name, cv2.WINDOW_NORMAL)

while True:
    
    current_time = time.time()
    
    if not paused:
        ret, frame = cap.read()
        
        if not ret:
            print("\n🎥 影片播放結束")
            break # 影片播放結束
                
        # --- 執行 YOLOv8 追蹤 ---
        results = model.track(frame, 
                              classes=[0], 
                              tracker='bytetrack.yaml', 
                              conf=0.6,
                              imgsz=INFERENCE_IMG_SIZE,
                              verbose=False)
        
        # --- 計算 Process FPS (整體處理速度) ---
        elapsed_time = current_time - prev_time 
        processing_fps = 1 / elapsed_time if elapsed_time > 0 else 0 
        prev_time = current_time 

        # --- 畫框 ---
        for result in results:
            if result.boxes.id is not None:
                boxes = result.boxes.xyxy.cpu().numpy().astype(int)
                track_ids = result.boxes.id.cpu().numpy().astype(int)
                
                for box, track_id in zip(boxes, track_ids):
                    x1, y1, x2, y2 = box
                    color = (0, 255, 0)
                    cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                    cv2.putText(frame, f"ID: {track_id}", (x1, y1 - 10),
                                cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)

        # 繪製 FPS 資訊到幀上
        cv2.putText(frame, f"FPS: {processing_fps:.2f}", (20, 40),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)

        if out.isOpened():
             out.write(frame)

        frame_count += 1 
    
    # --- 顯示與按鍵處理 ---
    if 'frame' in locals():
        cv2.imshow(window_name, frame)
    
    # cv2.waitKey(1) 必須保留，用於顯示畫面和處理按鍵事件
    key = cv2.waitKey(1) & 0xFF 
    
    if key == ord(' '): 
        paused = not paused
        if paused:
            print("⏸️ 影片暫停。")
        else:
            print("▶️ 影片繼續播放。")
            
    if key == ord('q'): 
        break

# --- 資源釋放與總結 FPS ---
cap.release()
if out.isOpened():
    out.release() 
    print(f"\n✅ 輸出影片已儲存至本機: {os.path.abspath(output_path)}")

cv2.destroyAllWindows() # 關閉所有 OpenCV 視窗

total_end_time = time.time()
total_time = total_end_time - total_start_time

if frame_count > 0:
    average_fps = frame_count / total_time
    print("\n-------------------------------------------------")
    print(f"總幀數: {frame_count}")
    print(f"總耗時: {total_time:.2f} 秒")
    print(f"🚀 **平均處理 FPS: {average_fps:.2f} FPS**")
    print("-------------------------------------------------")
else:
    print("❌ 影片處理失敗，無法計算平均 FPS。")


# =========================================================
# 步驟 3: 完成 (本機執行，不需下載)
# =========================================================
print("\n🎉 程式所有步驟執行完畢。請檢查輸出路徑下的影片檔案。")
